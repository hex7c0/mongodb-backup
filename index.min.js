"use strict";

var BSON, logger, meta, documentStore, systemRegex = /^system\./, fs = require("graceful-fs").gracefulify(require("fs-extra")), path = require("path"), fileSystemDocumentStore = function(root) {
    var dbDir = root, makeDir = function(pathname, next) {
        fs.stat(pathname, function(err, stats) {
            return err && "ENOENT" === err.code ? (logger("make dir at " + pathname), fs.mkdirp(pathname, function(err) {
                next(err, pathname);
            })) : stats && !1 === stats.isDirectory() ? (logger("unlink file at " + pathname), 
            fs.unlink(pathname, function(err) {
                if (err) return next(err);
                logger("make dir at " + pathname), fs.mkdir(pathname, function(err) {
                    next(err, pathname);
                });
            })) : void next(null, pathname);
        });
    };
    return {
        addDatabase: function(dbName, next) {
            return dbDir = path.join(root, dbName), makeDir(dbDir, next);
        },
        addCollection: function(relativePath, next) {
            var pathname = path.join(dbDir, relativePath);
            return makeDir(pathname, next);
        },
        store: function(collectionName, relativePath, content, callback) {
            fs.writeFile(path.join(dbDir, collectionName, relativePath), content, callback);
        },
        close: function() {}
    };
}, streamingDocumentStore = function(root, stream) {
    var pack = require("tar-stream").pack();
    pack.pipe(stream);
    var dbDir = root;
    return {
        addDatabase: function(dbName, next) {
            dbDir = path.join(root, dbName), pack.entry({
                name: dbDir,
                type: "directory"
            }), next();
        },
        addCollection: function(filename, next) {
            "" !== filename && pack.entry({
                name: path.join(dbDir, filename),
                type: "directory"
            }), next();
        },
        store: function(collectionName, filename, content, callback) {
            pack.entry({
                name: path.join(dbDir, collectionName, filename)
            }, content), callback && callback();
        },
        close: function() {
            pack.finalize();
        }
    };
};

function error(err) {
    err && logger(err.message);
}

function writeMetadata(collection, metadata, next) {
    return collection.indexes(function(err, indexes) {
        if (err) return next(err);
        documentStore.store(".metadata", collection.collectionName, JSON.stringify(indexes), next);
    });
}

function toJsonAsync(doc, collectionPath) {
    documentStore.store(collectionPath, doc._id + ".json", JSON.stringify(doc));
}

function toBsonAsync(doc, collectionPath) {
    documentStore.store(collectionPath, doc._id + ".bson", BSON.serialize(doc));
}

function allCollections(db, name, query, metadata, parser, next) {
    return db.collections(function(err, collections) {
        if (err) return next(err);
        var last = ~~collections.length, index = 0;
        if (0 === last) return next(err);
        collections.forEach(function(collection) {
            if (!0 === systemRegex.test(collection.collectionName)) return last === ++index ? next(null) : null;
            logger("select collection " + collection.collectionName), documentStore.addCollection(collection.collectionName, function(err) {
                if (err) return last === ++index ? next(err) : error(err);
                meta(collection, metadata, function() {
                    collection.find({
                        $query: query,
                        $snapshot: !0
                    }).stream().once("end", function() {
                        return last === ++index ? next(null) : null;
                    }).on("data", function(doc) {
                        parser(doc, collection.collectionName);
                    });
                });
            });
        });
    });
}

function allCollectionsScan(db, name, numCursors, metadata, parser, next) {
    return db.collections(function(err, collections) {
        if (err) return next(err);
        var last = ~~collections.length, index = 0;
        if (0 === last) return next(null);
        collections.forEach(function(collection) {
            if (!0 === systemRegex.test(collection.collectionName)) return last === ++index ? next(null) : null;
            logger("select collection scan " + collection.collectionName), documentStore.addCollection(collection.collectionName, function(err) {
                if (err) return last === ++index ? next(err) : error(err);
                meta(collection, metadata, function() {
                    collection.parallelCollectionScan({
                        numCursors: numCursors
                    }, function(err, cursors) {
                        if (err) return last === ++index ? next(err) : error(err);
                        var ii, cursorsDone;
                        if (0 === (ii = cursorsDone = ~~cursors.length)) return last === ++index ? next(null) : null;
                        for (var i = 0; i < ii; ++i) cursors[i].once("end", function() {
                            if (0 == --cursorsDone) return last === ++index ? next(null) : null;
                        }).on("data", function(doc) {
                            parser(doc, collection.collectionName);
                        });
                    });
                });
            });
        });
    });
}

function someCollections(db, name, query, metadata, parser, next, collections) {
    var last = ~~collections.length, index = 0;
    if (0 === last) return next(null);
    collections.forEach(function(collection) {
        db.collection(collection, {
            strict: !0
        }, function(err, collection) {
            if (err) return last === ++index ? next(err) : error(err);
            logger("select collection " + collection.collectionName), documentStore.addCollection(collection.collectionName, function(err) {
                if (err) return last === ++index ? next(err) : error(err);
                meta(collection, metadata, function() {
                    collection.find({
                        $query: query,
                        $snapshot: !0
                    }).stream().once("end", function() {
                        return last === ++index ? next(null) : null;
                    }).on("data", function(doc) {
                        parser(doc, collection.collectionName);
                    });
                });
            });
        });
    });
}

function someCollectionsScan(db, name, numCursors, metadata, parser, next, collections) {
    var last = ~~collections.length, index = 0;
    if (0 === last) return next(null);
    collections.forEach(function(collection) {
        db.collection(collection, {
            strict: !0
        }, function(err, collection) {
            if (err) return last === ++index ? next(err) : error(err);
            logger("select collection scan " + collection.collectionName), documentStore.addCollection(collection.collectionName, function(err) {
                if (err) return last === ++index ? next(err) : error(err);
                meta(collection, metadata, function() {
                    collection.parallelCollectionScan({
                        numCursors: numCursors
                    }, function(err, cursors) {
                        if (err) return last === ++index ? next(err) : error(err);
                        var ii, cursorsDone;
                        if (0 === (ii = cursorsDone = ~~cursors.length)) return last === ++index ? next(null) : null;
                        for (var i = 0; i < ii; ++i) cursors[i].once("end", function() {
                            if (0 == --cursorsDone) return last === ++index ? next(null) : null;
                        }).on("data", function(doc) {
                            parser(doc, collection.collectionName);
                        });
                    });
                });
            });
        });
    });
}

function wrapper(my) {
    var parser;
    if ("function" == typeof my.parser) parser = my.parser; else switch (my.parser.toLowerCase()) {
      case "bson":
        BSON = new (BSON = require("bson"))(), parser = toBsonAsync;
        break;

      case "json":
        parser = toJsonAsync;
        break;

      default:
        throw new Error("missing parser option");
    }
    var discriminator = allCollections;
    if (null !== my.collections ? (discriminator = someCollections, my.numCursors && (discriminator = someCollectionsScan, 
    my.query = my.numCursors)) : my.numCursors && (discriminator = allCollectionsScan, 
    my.query = my.numCursors), null === my.logger) logger = function() {}; else {
        (logger = require("logger-request")({
            filename: my.logger,
            standalone: !0,
            daily: !0,
            winston: {
                logger: "_mongo_b" + my.logger,
                level: "info",
                json: !1
            }
        }))("backup start");
        var log = require("mongodb").Logger;
        log.setLevel("info"), log.setCurrentLogger(function(msg) {
            return logger(msg);
        });
    }
    var metadata = "";
    function callback(err) {
        logger("backup stop"), null !== my.callback ? (logger("callback run"), my.callback(err)) : err && logger(err);
    }
    meta = !0 === my.metadata ? writeMetadata : function(a, b, c) {
        return c();
    }, require("mongodb").MongoClient.connect(my.uri, my.options).then(function(database) {
        var databaseName = database.s.options.dbName, db = database.db(databaseName);
        logger("db open"), documentStore.addDatabase(databaseName, function(err, name) {
            function go() {
                return discriminator(db, name, my.query, metadata, parser, function(err) {
                    if (logger("db close"), database.close(), err) return callback(err);
                    documentStore.close(), callback(null);
                }, my.collections);
            }
            if (err) return callback(err);
            !1 === my.metadata ? go() : documentStore.addCollection(".metadata", go);
        });
    }).catch(function(err) {
        return callback(err);
    });
}

function backup(options) {
    var opt = options || Object.create(null);
    if (!opt.uri) throw new Error("missing uri option");
    if (!opt.stream) {
        if (!opt.root) throw new Error("missing root option");
        if (fs.existsSync(opt.root) && !fs.statSync(opt.root).isDirectory()) throw new Error("root option is not a directory");
    }
    var rootPath = opt.root || "";
    "" !== rootPath && (rootPath = path.resolve(String(opt.root || "")));
    var my = {
        uri: String(opt.uri),
        root: rootPath + path.sep,
        stream: opt.stream || null,
        parser: opt.parser || "bson",
        numCursors: ~~opt.numCursors,
        collections: Array.isArray(opt.collections) ? opt.collections : null,
        callback: "function" == typeof opt.callback ? opt.callback : null,
        tar: "string" == typeof opt.tar ? opt.tar : null,
        query: "object" == typeof opt.query ? opt.query : {},
        logger: "string" == typeof opt.logger ? path.resolve(opt.logger) : null,
        options: "object" == typeof opt.options ? opt.options : {},
        metadata: Boolean(opt.metadata)
    };
    return my.tar && !my.stream && (my.stream = fs.createWriteStream(path.join(my.root, my.tar))), 
    my.stream ? (my.tar = !0, documentStore = streamingDocumentStore(my.root, my.stream)) : documentStore = fileSystemDocumentStore(my.root), 
    wrapper(my);
}

module.exports = backup;
